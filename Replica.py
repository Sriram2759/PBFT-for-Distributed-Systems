# -*- generated by 1.0.12 -*-
import da
PatternExpr_773 = da.pat.TuplePattern([da.pat.ConstantPattern('REQUEST'), da.pat.FreePattern('m')])
PatternExpr_891 = da.pat.TuplePattern([da.pat.ConstantPattern('done')])
PatternExpr_896 = da.pat.BoundPattern('_BoundPattern898_')
PatternExpr_936 = da.pat.TuplePattern([da.pat.ConstantPattern('View-Change'), da.pat.FreePattern('nv'), da.pat.FreePattern('m')])
PatternExpr_971 = da.pat.TuplePattern([da.pat.ConstantPattern('View-Change'), da.pat.BoundPattern('_BoundPattern974_'), da.pat.FreePattern('m')])
PatternExpr_978 = da.pat.FreePattern('a')
PatternExpr_1021 = da.pat.ConstantPattern('viewchanged')
PatternExpr_1025 = da.pat.FreePattern('a')
PatternExpr_1078 = da.pat.TuplePattern([da.pat.ConstantPattern('New-View'), da.pat.FreePattern('v'), da.pat.FreePattern('np')])
PatternExpr_1117 = da.pat.TuplePattern([da.pat.ConstantPattern('PREPREPARE'), da.pat.FreePattern('v'), da.pat.FreePattern('n'), da.pat.FreePattern('m'), da.pat.FreePattern('d')])
PatternExpr_1197 = da.pat.TuplePattern([da.pat.ConstantPattern('PREPARE'), da.pat.FreePattern('v'), da.pat.FreePattern('n'), da.pat.FreePattern('m'), da.pat.FreePattern('i'), da.pat.FreePattern('d')])
PatternExpr_1276 = da.pat.TuplePattern([da.pat.ConstantPattern('PREPARE'), da.pat.BoundPattern('_BoundPattern1279_'), da.pat.BoundPattern('_BoundPattern1280_'), da.pat.BoundPattern('_BoundPattern1281_'), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern1283_')])
PatternExpr_1286 = da.pat.FreePattern('a')
PatternExpr_1336 = da.pat.TuplePattern([da.pat.ConstantPattern('COMMIT'), da.pat.FreePattern('v'), da.pat.FreePattern('n'), da.pat.FreePattern('m'), da.pat.FreePattern('i'), da.pat.FreePattern('d')])
PatternExpr_1422 = da.pat.TuplePattern([da.pat.ConstantPattern('COMMIT'), da.pat.BoundPattern('_BoundPattern1425_'), da.pat.BoundPattern('_BoundPattern1426_'), da.pat.BoundPattern('_BoundPattern1427_'), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern1429_')])
PatternExpr_1432 = da.pat.FreePattern('a')
PatternExpr_1572 = da.pat.TuplePattern([da.pat.ConstantPattern('done')])
PatternExpr_1577 = da.pat.BoundPattern('_BoundPattern1579_')
PatternExpr_1580 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern1586_')]), da.pat.TuplePattern([da.pat.ConstantPattern('done')])])
PatternExpr_899 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern905_')]), da.pat.TuplePattern([da.pat.ConstantPattern('done')])])
_config_object = {'channnel': 'fifo', 'clock': 'lamport'}
import sys
sys.setrecursionlimit(100000)
import time
import random
import hashlib
import copy
from collections import OrderedDict
controller_module = da.import_da('controller')
NOPS = 4

def execute(input):
    res = (- 9999)
    if (input[0] == 1):
        res = (input[1] + input[2])
    elif (input[0] == 2):
        res = (input[1] - input[2])
    elif (input[0] == 3):
        res = (input[1] * input[2])
    if (input[0] == 4):
        res = (input[1] / input[2])
    return res

class Replica(controller_module.Controllee, da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._ReplicaReceivedEvent_1 = []
        self._ReplicaReceivedEvent_3 = []
        self._ReplicaReceivedEvent_4 = []
        self._ReplicaReceivedEvent_8 = []
        self._ReplicaReceivedEvent_10 = []
        self._ReplicaReceivedEvent_11 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_0', PatternExpr_773, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_772]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_1', PatternExpr_891, sources=[PatternExpr_896], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_2', PatternExpr_936, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_935]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_3', PatternExpr_971, sources=[PatternExpr_978], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_4', PatternExpr_1021, sources=[PatternExpr_1025], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_5', PatternExpr_1078, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_1077]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_6', PatternExpr_1117, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_1116]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_7', PatternExpr_1197, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_1196]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_8', PatternExpr_1276, sources=[PatternExpr_1286], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_9', PatternExpr_1336, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_1335]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_10', PatternExpr_1422, sources=[PatternExpr_1432], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_11', PatternExpr_1572, sources=[PatternExpr_1577], destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, ctl, replicas, initial_state, viewNumber, byzantineset, maxfaultnum, ndelay, rdelay, timeout, test_agent, **rest_1607):
        super().setup(ctl=ctl, replicas=replicas, initial_state=initial_state, viewNumber=viewNumber, byzantineset=byzantineset, maxfaultnum=maxfaultnum, ndelay=ndelay, rdelay=rdelay, timeout=timeout, test_agent=test_agent, **rest_1607)
        self._state.ctl = ctl
        self._state.replicas = replicas
        self._state.initial_state = initial_state
        self._state.viewNumber = viewNumber
        self._state.byzantineset = byzantineset
        self._state.maxfaultnum = maxfaultnum
        self._state.ndelay = ndelay
        self._state.rdelay = rdelay
        self._state.timeout = timeout
        self._state.test_agent = test_agent
        super().setup(self._state.ctl)
        self._state.slot_num = 1
        self._state.viewNumber = self._state.viewNumber
        self._state.sequenceNumber = 0
        self._state.messagelog = set()
        self._state.prepared = set()
        self._state.commited_local = set()
        self._state.commited = set()
        self._state.primaryreplica = self._state.replicas[0]
        self._state.running = 'True'
        self._state.netwrkdelay = self._state.ndelay
        self._state.replicadelay = self._state.rdelay
        self._state.timeout_value = self._state.timeout
        self._state.result = (- 898989898989)
        self._state.requestset = dict()
        self._state.donelog = set()
        self._state.otherreplicas = copy.deepcopy(list(self._state.replicas))
        self._state.otherreplicas.remove(self._id)
        self._state.executedlist = [0]
        self._state.stage = ''
        self._state.prep = 0
        self._state.cantimeronn = 'True'
        self._state.prepreparelog = set()

    @controller_module.run
    def run(self):
        super()._label('_st_label_1569', block=False)
        _st_label_1569 = 0
        while (_st_label_1569 == 0):
            _st_label_1569 += 1
            if PatternExpr_1580.match_iter(self._ReplicaReceivedEvent_11, _BoundPattern1586_=self.parent(), SELF_ID=self._id):
                _st_label_1569 += 1
            else:
                super()._label('_st_label_1569', block=True)
                _st_label_1569 -= 1
        self.output(self._state.executedlist)
        self.send(('ReplicaInfo', self._state.executedlist, len(self._state.messagelog), self._id), to=self._state.test_agent)
        self.send(('done',), to=self.parent())

    def getprimary(self):
        key = (self._state.viewNumber % len(self._state.replicas))
        self._state.primaryreplica = self._state.replicas[key]

    def isprimary(self):
        key = (self._state.viewNumber % len(self._state.replicas))
        if (self._state.replicas[key] == self._id):
            return True
        else:
            return False

    def isnewprimary(self, nv):
        key = (nv % len(self._state.replicas))
        if (self._state.replicas[key] == self._id):
            return True
        else:
            return False

    def calculatedigest(self, data):
        hashId = hashlib.md5()
        hashId.update(repr(data).encode('utf-8'))
        d = hashId.hexdigest()
        return d

    def getMaxTorelentNumber(self):
        n = len(self._state.replicas)
        f = ((n - 1) / 3)
        return f

    def tuplefinder(self, type):
        temp = set()
        temp = [x for x in self._state.messagelog if (x[0] == type)]
        return temp

    def configuredsend(self, MainMessage, destination):
        CorruptedMessage = ('Corrupted message', 'KJSHSA', 'DSKHDSKHDS', 'S,KDHSKHDSIDH')
        CorruptedResult = 'djsgduihnsd838261389273'
        CorruptedSeqNo = 9999
        CorruptedViewNo = (- 9999)
        Corrupteddigest = 'snjndjsdjd'
        MainMessage = list(MainMessage)
        if (self._id in self._state.byzantineset):
            if (MainMessage[0] == 'PREPARE'):
                MainMessage[3] = CorruptedMessage
                MainMessage[4] = self.calculatedigest(CorruptedMessage)
            elif (MainMessage[0] == 'REPLY'):
                MainMessage[5] = CorruptedResult
            elif (MainMessage[0] == 'View-Change'):
                MainMessage[1] = CorruptedSeqNo
                MainMessage[2] = CorruptedViewNo
            elif (MainMessage[0] == 'COMMIT'):
                MainMessage[3] = CorruptedMessage
                MainMessage[5] = self.calculatedigest(CorruptedMessage)
            elif (MainMessage[0] == 'PREPREPARE'):
                MainMessage[4] = Corrupteddigest
                MainMessage[2] = CorruptedSeqNo
            self._state.messagelog.add(tuple(MainMessage))
            time.sleep(self._state.netwrkdelay)
            self.send(tuple(MainMessage), to=destination)
        else:
            if (MainMessage[0] == 'PREPREPARE'):
                if (not (MainMessage[3] in self._state.requestset)):
                    self._state.prep += 1
                    MainMessage[2] = self._state.prep
                    self._state.requestset[MainMessage[3]] = self._state.prep
                else:
                    MainMessage[2] = self._state.requestset[MainMessage[3]]
            self._state.messagelog.add(tuple(MainMessage))
            self.send(tuple(MainMessage), to=destination)

    def initiatebackuptimer(self, m):
        self.output('in backup')
        super()._label('_st_label_883', block=False)
        _st_label_883 = 0
        self._timer_start()
        while (_st_label_883 == 0):
            _st_label_883 += 1
            if (m in self._state.prepreparelog):
                pass
                _st_label_883 += 1
            elif PatternExpr_899.match_iter(self._ReplicaReceivedEvent_1, _BoundPattern905_=self.parent(), SELF_ID=self._id):
                pass
                _st_label_883 += 1
            elif self._timer_expired:
                '\n\t\t\tIt stops accepting messages (other than checkpoint, view-change, and new-view messages) and multicasts a \n\t\t\t<VIEW-CHANGE, v+1, n, C, P, i> message to all replicas. Here n is the sequence number of the last stable checkpoint s known to i,\n\t\t\tC is a set of 2f+1 valid checkpoint messages providing the correctness of s, and P is a set containing a set Pm for\n\t\t\teach request m that prepared at i with a sequence number higher than n.\n\t\t\t'
                k = (self._state.viewNumber + 1)
                self.output('initiating view change', k)
                self.configuredsend(('View-Change', k, m), self._state.replicas)
                _st_label_883 += 1
            else:
                super()._label('_st_label_883', block=True, timeout=self._state.timeout_value)
                _st_label_883 -= 1

    def _Replica_handler_772(self, m):
        '\n\t\tIf the request has already been processed, the replicas simply re-send the reply; \n\t\treplicas remember the last reply message they sent to each client. \n\t\tOtherwise, if the replica is not the primary, it relays the request to the primary.\n\t\t'
        replymsg = [tuple for tuple in self._state.messagelog if ((tuple[0] == 'REPLY') and (tuple[2] == m[2]))]
        if (len(replymsg) > 0):
            self.send(replymsg[0], to=m[0])
        else:
            '\n\t\t\tIn the pre-prepare phase, the primary assigns a sequence number, n, to the request,\n\t\t\tmulticasts a pre-prepare message with m piggybacked to all the backups, \n\t\t\tand appends the message to its log.\n\t\t\t'
            if self.isprimary():
                data = ('REQUEST', m)
                d = self.calculatedigest(data)
                time.sleep(0.002)
                self.configuredsend(('PREPREPARE', self._state.viewNumber, self._state.sequenceNumber, m, d), self._state.otherreplicas)
            else:
                self.send(('REQUEST', m), to=self._state.primaryreplica)
                '\n\t\t\t\tFor View-Change Protocol: A backup is waiting for a request if it received a valid request and has not executed it. \n\t\t\t\tA backup starts a timer when it receives a request and the timer is not already running.\n\t\t\t\tIt stops the timer when it is no longer waiting to execute the request, \n\t\t\t\tbut restarts it if at that point it is waiting to execute some other request.\n\t\t\t\tIf the timer of backup expires in view , the backup starts a view change to move the system to view v+1. \n\t\t\t\tIt stops accepting messages (other than checkpoint, view-change, and new-view messages) and multicasts a VIEW-CHANGE message to all replicas. \n\t\t\t\t'
                if (not (self._state.stage == 'inbackupphase')):
                    self._state.stage = 'inbackupphase'
                    self.initiatebackuptimer(m)
    _Replica_handler_772._labels = None
    _Replica_handler_772._notlabels = None

    def _Replica_handler_935(self, nv, m):
        f = self.getMaxTorelentNumber()
        if (self.isnewprimary(nv) and (not ('viewchanged' in self._state.messagelog))):
            self.output('nv')
            f = self.getMaxTorelentNumber()
            if ((len({a for (_, (_, _, a), (_ConstantPattern989_, _BoundPattern991_, m)) in self._ReplicaReceivedEvent_3 if (_ConstantPattern989_ == 'View-Change') if (_BoundPattern991_ == nv)}) >= (2 * f)) or (f == 0)):
                self.send(('New-View', nv, self._id), to=self._state.replicas)
                self._state.messagelog.add('View-Change')
                super()._label('_st_label_1015', block=False)
                _st_label_1015 = 0
                while (_st_label_1015 == 0):
                    _st_label_1015 += 1
                    if ((len({a for (_, (_, _, a), _ConstantPattern1035_) in self._ReplicaReceivedEvent_4 if (_ConstantPattern1035_ == 'viewchanged')}) == ((3 * f) + 1)) or (f == 0)):
                        _st_label_1015 += 1
                    else:
                        super()._label('_st_label_1015', block=True)
                        _st_label_1015 -= 1
                self.output('view change done')
                data = ('REQUEST', m)
                d = self.calculatedigest(data)
                self.configuredsend(('PREPREPARE', self._state.viewNumber, self._state.sequenceNumber, m, d), self._state.otherreplicas)
    _Replica_handler_935._labels = None
    _Replica_handler_935._notlabels = None

    def _Replica_handler_1077(self, v, np):
        self._state.primaryreplica = np
        self._state.viewNumber = v
        self._state.stage = 'Normal'
        self._state.messagelog.add('viewchanged')
        self.send('viewchanged', to=np)
    _Replica_handler_1077._labels = None
    _Replica_handler_1077._notlabels = None

    def _Replica_handler_1116(self, v, n, m, d):
        data = ('REQUEST', m)
        if ((self._state.viewNumber == v) and (str(d) == str(self.calculatedigest(data)))):
            self._state.prepreparelog.add(m)
            self._state.messagelog.add(('PREPREPARE', v, n, m, d))
            self._state.messagelog.add(('PREPARE', v, n, m, self._id, d))
            '\n\t\t\tAs per paper , this message must be sent to all other replicas, but code wise it was not working\n\t\t\tSo had to send this message to all the replicas\n\t\t\t'
            self.configuredsend(('PREPARE', v, n, m, self._id, d), self._state.replicas)
    _Replica_handler_1116._labels = None
    _Replica_handler_1116._notlabels = None

    def _Replica_handler_1196(self, v, n, m, i, d):
        data = ('REQUEST', m)
        if ((self._state.viewNumber == v) and (str(d) == str(self.calculatedigest(data)))):
            self._state.messagelog.add(('PREPARE', v, n, m, i, d))
            '\n\t\t\tWe define the predicate prepared to be true if and only if replica has inserted in its log: \n\t\t\tthe request, \n\t\t\ta PRE-PREPARE for in view with sequence number, \n\t\t\tand 2f PREPARE from different backups that match the PRE-PREPARE. \n\t\t\tThe replicas verify whether the PREPARE match the PRE-PREPARE by checking that\n\t\t\tthey have the same view, sequence number, and digest.\n\t\t\t'
            if ((('PREPREPARE', v, n, m, d) in self._state.messagelog) and (not ((m, n, v, self._id, d) in self._state.prepared))):
                f = self.getMaxTorelentNumber()
                if (len({a for (_, (_, _, a), (_ConstantPattern1297_, _BoundPattern1299_, _BoundPattern1300_, _BoundPattern1301_, _, _BoundPattern1303_)) in self._ReplicaReceivedEvent_8 if (_ConstantPattern1297_ == 'PREPARE') if (_BoundPattern1299_ == v) if (_BoundPattern1300_ == n) if (_BoundPattern1301_ == m) if (_BoundPattern1303_ == d)}) >= (2 * f)):
                    self._state.prepared.add((m, n, v, self._id, d))
                    '\n\t\t\t\t\tReplica multicasts a COMMIT message to the other replicas when prepared becomes true.\n\t\t\t\t\tThis starts the commit phase.\n\t\t\t\t\t'
                    self.configuredsend(('COMMIT', v, n, m, self._id, d), self._state.replicas)
    _Replica_handler_1196._labels = None
    _Replica_handler_1196._notlabels = None

    def _Replica_handler_1335(self, v, n, m, i, d):
        data = ('REQUEST', m)
        if ((self._state.viewNumber == v) and (str(d) == str(self.calculatedigest(data)))):
            cnt = 0
            f = self.getMaxTorelentNumber()
            self._state.messagelog.add(('COMMIT', v, n, m, i, d))
            '\n\t\t\tWe define the committed and committed-local predicates as follows: \n\t\t\tcommitted is true if and only if prepared is true for all in some set of f+1 non-faulty replicas; \n\t\t\tand committed-local is true if and only if prepared is true and has accepted 2f+1 COMMIT(possibly including its own)\n\t\t\tfrom different replicas that match the PRE-PREPARE for m;\n\t\t\ta COMMIT matches a PRE-PREPARE if they have the same view, sequence number, and digest.\n\t\t\t'
            f = self.getMaxTorelentNumber()
            if (((m, n, v, self._id, d) in self._state.prepared) and (not ((m, v, n, self._id) in self._state.commited_local))):
                if (len({a for (_, (_, _, a), (_ConstantPattern1443_, _BoundPattern1445_, _BoundPattern1446_, _BoundPattern1447_, _, _BoundPattern1449_)) in self._ReplicaReceivedEvent_10 if (_ConstantPattern1443_ == 'COMMIT') if (_BoundPattern1445_ == v) if (_BoundPattern1446_ == n) if (_BoundPattern1447_ == m) if (_BoundPattern1449_ == d)}) >= ((2 * f) + 1)):
                    self._state.messagelog.add(('COMMIT', v, n, m, i, d))
                    self._state.commited_local.add((m, v, n, self._id))
                    '\n\t\t\t\t\tEach replica executes the operation requested by after committed-local is true and replica’s state\n\t\t\t\t\treflects the sequential execution of all requests with lower sequence numbers.\n\t\t\t\t\tAfter executing the requested operation, replicas send a reply to the client.\n\t\t\t\t\tReplicas discard requests whose timestamp is lower than\n\t\t\t\t\tthe timestamp in the last reply they sent to the client to\n\t\t\t\t\tguarantee exactly-once semantics.\n\t\t\t\t\t'
                    sortedcommited = copy.deepcopy(list(self._state.commited_local))
                    sortedcommited.sort(key=(lambda tup: tup[2]))
                    for i in range(0, len(sortedcommited)):
                        (m2, v2, n2, s2) = sortedcommited[i]
                        if (n2 in self._state.executedlist):
                            continue
                        if (not (n2 == (max(self._state.executedlist) + 1))):
                            break
                        (client, op, t, cid) = m2
                        self._state.result = execute(op)
                        self.configuredsend(('REPLY', v2, t, self._id, cid, self._state.result), client)
                        self._state.executedlist.append(n2)
    _Replica_handler_1335._labels = None
    _Replica_handler_1335._notlabels = None
